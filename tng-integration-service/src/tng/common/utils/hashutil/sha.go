package hashutil

import (
	"crypto/hmac"
	"crypto/md5"
	"crypto/rand"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/base64"
	"encoding/hex"
	"fmt"

	"golang.org/x/crypto/pbkdf2"
)

const (
	// Pbkdf2Iterations sets the amount of iterations used by the PBKDF2 hashing algorithm
	Pbkdf2Iterations int = 15000
	// HashBytes sets the amount of bytes for the hash output from the PBKDF2 / scrypt hashing algorithm
	HashBytes int = 64
	// UniqueKey Key
	UniqueKey = "!!!!"
)

// GenerateSaltPassword return a encoded base64 from random sequence number
func GenerateSaltPassword() (string, error) {
	salt := make([]byte, 64)
	_, err := rand.Read(salt)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(salt), nil
}

// GenerateShaHashPassword return hashed password generated by Key Derivation Pbkdf2 algorithm
func GenerateShaHashPassword(password, saltPassword string) string {
	key, _ := base64.StdEncoding.DecodeString(saltPassword)
	bytes := pbkdf2.Key([]byte(password+UniqueKey), key, Pbkdf2Iterations, HashBytes, sha512.New)
	return hex.EncodeToString(bytes)
}

// VerifyShaHashedPassword return true if password math hashed password store in database
// or fail if not math
func VerifyShaHashedPassword(password, hashedPassword, saltPassword string) bool {
	return GenerateShaHashPassword(password, saltPassword) == hashedPassword
}

// GetMD5Hash returns a MD5 string from text.
func GetMD5Hash(text string) string {
	hasher := md5.New()
	if _, err := hasher.Write([]byte(text)); err != nil {
		return ""
	}
	return hex.EncodeToString(hasher.Sum(nil))
}

func GetSHA256(v string) string {
	h := sha256.New()

	if _, err := h.Write([]byte(v)); err != nil {
		return ""
	}
	return fmt.Sprintf("%x", h.Sum(nil))
}
func GetHmacSHA256(k, v string) string {
	h := hmac.New(sha256.New, []byte(k))
	h.Write([]byte(v))
	sha := hex.EncodeToString(h.Sum(nil))
	return sha
}
